# Полный гайд для новичка (как устроен проект, кто с кем общается, что делает каждый метод)

Ниже максимально подробное описание фронтенда, бэкенда, базы и инфраструктуры. Цель — чтобы человек «с нуля» понял, как все собрано, какие запросы делать и что происходит внутри.

## 1. Картина целиком
1. Проект состоит из фронта (статический HTML/CSS/JS) и бэкенда (Express + PostgreSQL).
2. Бэкенд поднимается как сервис `backend`, база как сервис `db` (docker-compose).
3. Фронт собирается без сборщиков: `frontend/index.html`, `styles.css`, `script.js` отдаются напрямую Express’ом.
4. Главные сущности в БД: `users` (аккаунты) и `posts` (карточки объявлений/точки на карте).
5. Авторизация — по JWT. Токен хранится на фронте в `localStorage` и уходит в заголовке `Authorization: Bearer <token>`.
6. Карта Leaflet показывает точки из таблицы `posts`, если у записи есть `latitude` и `longitude`.
7. Дашборд (Chart.js + таблица) читает данные с `/api/posts` и строит график/таблицу.
8. Слайдер карточек и фильтры тоже работают на данных из `/api/posts`.
9. Создание/редактирование/удаление постов доступно только авторизованному пользователю — проверка на сервере по токену и авторству.
10. Демо-данные сидятся автоматически при старте: один пользователь `demo@elitetime.ru` и три карточки часов.

## 2. Фронтенд: что есть на странице
1. Хедер с логотипом, навигацией, бургером (для мобилок) и чипом «текущий пользователь».
2. Hero-секция: текст о проекте, CTA-кнопки, плавающие карточки часов (анимация), метрики (кол-во карточек, средний рейтинг, города).
3. Каталог/слайдер: список карточек объявлений с авто-прокруткой, стрелками, фильтром по названию и рейтингу.
4. Дашборд: график Chart.js (кол-во объявлений по городам) и сортируемая/фильтруемая таблица.
5. Карта: Leaflet, кнопка «Определить меня», статус геолокации, маркеры из БД, попап с инфо по клику.
6. Личный кабинет: формы регистрации, логина и создания новой карточки (с координатами, ценой, рейтингом, городом).
7. Футер: краткое описание стека и API.

## 3. Фронтенд: ключевые файлы и функции
1. `frontend/index.html` — разметка всей страницы, подключение стилей, Leaflet, Chart.js, GSAP и `script.js`.
2. `frontend/styles.css` — темы, сетки, адаптив, анимации (keyframes), состояния :hover, loader, mobile-first.
3. `frontend/script.js` — логика: запросы к API, отрисовка слайдера, таблицы, графика, карты, формы auth/создания постов, фильтры, сортировки, геолокация, плавный скролл, GSAP-анимация hero.
4. В `script.js` глобальные переменные: `API_BASE = '/api'`, `posts` (кэш ленты), `authToken`, `currentUser`, `cachedCoords`.
5. Основные функции:
   - `fetchPosts()` — забирает `/api/posts`, кладет в `posts`, запускает фильтры/рендеры.
   - `renderSlider(data)` — собирает карточки и сбрасывает индекс.
   - `slide(delta)` — листает слайдер, автопрокрутка через `setInterval`.
   - `renderTable(data)` — таблица для дашборда.
   - `updateChart(data)` — пересоздает график Chart.js по городам.
   - `initMap()` — создаёт карту Leaflet, слой маркеров.
   - `renderMarkers(data)` — ставит маркеры по координатам.
   - `handleGeo()` — просит геолокацию у браузера, ставит круг на карте и кэширует coords.
   - `registerUser()`, `loginUser()` — auth, сохраняет токен/пользователя в localStorage.
   - `createPost()` — POST `/api/posts` с токеном.
   - `getFilteredPosts()` — применяет поиски/фильтры/сортировку к локальному `posts`.
   - `applyFilters()` — обновляет UI (слайдер, таблица, метрики, график, маркеры).
   - `animateHero()` — GSAP-анимация элементов hero.
   - `smoothAnchors()` — плавный скролл по якорям.
6. Навигация по бургеру: `.nav-toggle` добавляет/снимает класс `.open` у `.nav-links` на мобилках.
7. Фильтры: поиск по названию, минимальный рейтинг, поиск по таблице (город/автор), сброс фильтров.
8. Сортировка таблицы: клики по `<th data-sort="...">` меняют порядок по выбранному полю (title, rating, price, city, author).
9. Геолокация: кнопка «Определить меня» + кнопка «Подставить мою геолокацию» в форме создания карточки.
10. Токен хранится в localStorage — при загрузке `initAuthState()` подставляет имя пользователя и активирует форму создания.

## 4. Бэкенд: архитектура и файлы
1. `backend/src/server.js` — точка входа: Express, миддлвары, маршруты, статика фронта, healthcheck, запуск.
2. `backend/src/config.js` — конфиг: PORT, DATABASE_URL, JWT_SECRET, FRONTEND_DIR, isDev.
3. `backend/src/db/pool.js` — пул соединений `pg` к Postgres.
4. `backend/src/db/init.js` — миграции (CREATE TABLE IF NOT EXISTS) и сиды (демо-пользователь + 3 поста).
5. `backend/src/middleware/auth.js` — проверка JWT, установка `req.user`.
6. `backend/src/routes/auth.js` — `POST /api/register`, `POST /api/login`, `GET /api/profile`.
7. `backend/src/routes/posts.js` — CRUD: `GET /api/posts`, `GET /api/posts/:id`, `POST /api/posts`, `PUT /api/posts/:id`, `DELETE /api/posts/:id`.
8. `backend/package.json` — зависимости (express, pg, bcryptjs, jsonwebtoken, morgan, cors, dotenv, nodemon).
9. `Dockerfile` — образ Node 20-alpine, копия backend+frontend, команда `node backend/src/server.js`.
10. `docker-compose.yml` — сервисы `db` (postgres) и `backend` (node).

## 5. Бэкенд: детально по методам
1. `GET /api/health` — проверка БД (SELECT 1), возвращает `{status:"ok"}` либо ошибку 500.
2. `POST /api/register`
   - Тело: `{ name, email, password }`.
   - Проверки: все поля обязательны, email валиден, пароль ≥ 6 символов.
   - Если email занят — 409.
   - Сохранение: bcrypt.hash, INSERT INTO users, возврат `{ token, user }`.
   - JWT payload: `{ id, email, name }`, срок 7 дней.
3. `POST /api/login`
   - Тело: `{ email, password }`.
   - Проверка существования пользователя, сравнение bcrypt.compare.
   - На успех: `{ token, user }`.
4. `GET /api/profile` (защищенный)
   - Требует заголовок Authorization.
   - Достает пользователя по `req.user.id`, возвращает `{ id, name, email, created_at }`.
5. `GET /api/posts`
   - Query: `search`, `minRating`, `city`, `sort`.
   - WHERE по search (title/body, ILIKE), minRating (>=), city (равенство), LIMIT 100.
   - ORDER: по цене (DESC) если sort=price, иначе по дате (DESC).
   - Возвращает поля поста + имя автора.
6. `GET /api/posts/:id`
   - Валидация ID, 404 если нет, возвращает одну запись с автором.
7. `POST /api/posts` (защищенный)
   - Тело: `title` (обязательно), `body`, `rating` (1–5), `price`, `city`, `latitude`, `longitude`.
   - user_id берется из токена.
   - INSERT, затем выборка созданной записи и возврат 201.
8. `PUT /api/posts/:id` (защищенный)
   - Проверка ID, проверка что `user_id` совпадает с `req.user.id`.
   - Валидация рейтинга (если передан).
   - UPDATE с COALESCE, возврат обновленной записи.
9. `DELETE /api/posts/:id` (защищенный)
   - Проверка ID и авторства, DELETE, возврат 204.

## 6. Бэкенд: как обрабатываются ошибки
1. Невалидный токен или отсутствие заголовка — 401.
2. Несовпадение авторства при PUT/DELETE — 403.
3. Нет записи/пользователя — 404.
4. Ошибки валидации тела — 400 (например, пустой title или рейтинг вне 1–5).
5. Любая серверная ошибка — 500 с сообщением «Не удалось ...».

## 7. База данных (Postgres)
1. Таблица `users`: `id`, `name`, `email unique`, `password_hash`, `created_at`.
2. Таблица `posts`: `id`, `user_id` (FK), `title`, `body`, `rating` (1–5), `price`, `city`, `latitude`, `longitude`, `created_at`.
3. Индекс `idx_posts_user_id` для быстрых выборок по пользователю.
4. Сиды: создается demo-пользователь (`demo1234`) и три поста с координатами (Москва, СПб, Сочи).
5. Схема продублирована в `docs/schema.sql`.

## 8. Docker и окружение
1. `docker-compose.yml`:  
   - `db`: образ `postgres:15-alpine`, порт `55432:5432`, volume `./docker-data/postgres`.  
   - `backend`: build из `Dockerfile`, порт `3000:3000`, env `DATABASE_URL=postgres://elitetime:elitetime@db:5432/elitetime`.
2. `.env` (локальный запуск): `PORT`, `DATABASE_URL`, `JWT_SECRET`, `FRONTEND_DIR`, `DB_SSL`.
3. При `docker-compose up --build` фронт и API доступны на `http://localhost:3000`, Postgres — `localhost:55432`.
4. Для подключения psql с хоста: `psql -h localhost -p 55432 -U elitetime -d elitetime`.
5. Если порт 55432 занят — поменяйте маппинг `ports` в compose или остановите локальный Postgres.

## 9. Типовой сценарий работы пользователя (UI)
1. Зайти на `http://localhost:3000`.
2. Посмотреть демо-данные: карточки в слайдере, таблице, графике, маркеры на карте.
3. Нажать «Определить меня» — карта центрируется на пользователя, статус обновится.
4. Войти демо-аккаунтом или зарегистрироваться.
5. После входа форма создания карточки активна: ввести название, описание, рейтинг, цену, город, координаты (можно подставить свои).
6. Отправить — новая карточка появится в ленте, таблице, графике, на карте.
7. Проверить фильтры и сортировки: поиск, рейтинг, город, сортировка таблицы.
8. При необходимости обновить или удалить свою карточку (PUT/DELETE).

## 10. Типовой сценарий работы через API (Postman/cURL)
1. `POST /api/login` с demo-данными → получить `token`.
2. `GET /api/posts` → увидеть список с фильтрами.
3. `POST /api/posts` с заголовком Authorization: `Bearer <token>` и телом с координатами → создать запись.
4. `GET /api/posts/:id` → проверить, что запись есть.
5. `PUT /api/posts/:id` → обновить (например, цену или город).
6. `DELETE /api/posts/:id` → удалить.
7. `GET /api/profile` → проверить, что токен работает.

## 11. Связи и ответственность компонентов
1. Фронт отвечает за UI, фильтрацию/сортировку на клиенте и отправку запросов к API.
2. Бэкенд отвечает за валидацию, авторизацию, доступ к БД, хэширование паролей, логику авторства.
3. Postgres хранит данные: пользователей и посты с координатами.
4. Leaflet на фронте визуализирует геоданные из `/api/posts`.
5. Chart.js визуализирует агрегированные данные (количество постов по городам).
6. GSAP и CSS-анимации отвечают за плавные появления и интерактивность.
7. Docker orchestration обеспечивает легкий запуск всех сервисов одним `docker-compose up`.

## 12. Безопасность (базовые аспекты)
1. Пароли хэшируются через bcrypt (10 salt rounds).
2. JWT хранит id/email/name, срок 7 дней (задано в `auth.js`).
3. Токен проверяется в `middleware/auth.js` перед защищенными маршрутами.
4. Авторство поста проверяется перед PUT/DELETE (сравнение `user_id` и `req.user.id`).
5. Валидация входных данных на сервере: обязательные поля, длина пароля, диапазон рейтинга.
6. CORS включен (`app.use(cors())`), но в продакшене можно ограничить origin.
7. В проде обязательно переопределить `JWT_SECRET` и `DATABASE_URL` через переменные окружения.

## 13. Производительность и лимиты
1. `/api/posts` возвращает максимум 100 записей (LIMIT 100).
2. Фильтры выполняются на сервере через SQL (WHERE + LIKE/ILIKE).
3. Индекс по `user_id` ускоряет запросы на обновление/удаление своих постов.
4. Легковесный фронт без сборки — быстрая отдача статики.
5. Chart.js и Leaflet работают на клиентских данных — нет доп. запросов после загрузки ленты.

## 14. Анимации и UX
1. CSS keyframes: плавающие карточки, loader (spinner), плавные переходы.
2. GSAP: плавное появление элементов hero.
3. Плавный скролл к якорям через нативный `scrollIntoView`.
4. Hover-состояния: кнопки, карточки, навигация.
5. Автослайдер: автопрокрутка каждые 4.2 сек + ручные стрелки.

## 15. Геолокация и карта
1. Кнопка «Определить меня» вызывает `navigator.geolocation.getCurrentPosition`.
2. Успех: координаты ставятся в статус, карта центрируется, рисуется circleMarker.
3. Кэш coords можно подставить в форму создания поста кнопкой «Подставить мою геолокацию».
4. Маркеры из БД появляются, если у поста есть `latitude` и `longitude`.
5. Попап содержит название, город, рейтинг и цену.

## 16. Как добавить новую фичу (пример: категории)
1. БД: добавить поле `category` в `posts` (ALTER TABLE).
2. Бэкенд: обновить INSERT/UPDATE/SELECT, добавить фильтр/сортировку по `category`.
3. Фронт: добавить поле в форму создания, обновить фильтры и рендер карточек/таблицы.
4. Дополнить сиды новыми категориями.
5. Обновить документацию (`docs/API_AND_FLOW.md`, README).

## 17. Как сменить СУБД или строку подключения
1. В `.env` или переменных окружения поменять `DATABASE_URL`.
2. В `docker-compose.yml` при необходимости поменять образ/порты.
3. Учесть SSL: установить `DB_SSL=true`, если нужно.
4. Пересобрать контейнеры: `docker-compose up --build`.

## 18. Как деплоить (базовый сценарий)
1. Собрать Docker-образ: `docker build -t elitetime:latest .`
2. Запустить в проде с внешним Postgres: задать `DATABASE_URL` и `JWT_SECRET`.
3. Пробросить порт 3000 наружу или поставить реверс-прокси (Nginx) с HTTPS.
4. Хранить `.env` вне репозитория, использовать секреты CI/CD.

## 19. Тестирование (ручные проверки)
1. Healthcheck: `curl http://localhost:3000/api/health`.
2. Auth: зарегистрироваться, залогиниться, проверить `GET /api/profile`.
3. CRUD: создать пост, обновить его, удалить, убедиться в корректных кодах 201/200/204.
4. Валидация: попробовать создать пост без title — получить 400.
5. Авторство: попытаться удалить чужой пост — получить 403.
6. Фронт: убедиться, что карточки/таблица/график/карта обновляются после создания поста.

## 20. Траблшутинг частых проблем
1. Порт 5432/55432 занят — поменять `ports` в compose или остановить локальный Postgres.
2. `npm` не найден — установить Node.js или запускать через Docker.
3. Пустая карта — у постов нет координат; добавьте lat/long при создании.
4. 401 при создании/удалении — нет токена или истекший токен; залогиньтесь заново.
5. 403 при обновлении/удалении — карточка не ваша.
6. Ошибка подключения к БД — проверьте `DATABASE_URL`, запущен ли сервис `db`, правильный порт.
7. Кракозябры в терминале Windows — убедитесь, что кодировка UTF-8 или используйте PowerShell ISE.

## 21. Где найти что в репозитории
1. `frontend/index.html` — вся разметка.
2. `frontend/styles.css` — стили и анимации.
3. `frontend/script.js` — логика фронта.
4. `backend/src/server.js` — точка входа сервера.
5. `backend/src/routes/auth.js` — методы auth.
6. `backend/src/routes/posts.js` — CRUD постов.
7. `backend/src/db/init.js` — миграции/сиды.
8. `docs/schema.sql` — схема таблиц.
9. `docs/API_AND_FLOW.md` — краткое руководство по методам.
10. `docs/FULL_ONBOARDING_GUIDE.md` — этот файл с развернутым описанием.

## 22. Подробно о сидировании (init.js)
1. При старте `runMigrations()` создает таблицы, если их нет.
2. Затем `seedDemoData()` проверяет наличие пользователей.
3. Если пользователей нет — создает demo-пользователя с паролем `demo1234`.
4. Если постов нет — вставляет три записи с координатами (Москва, СПб, Сочи).
5. Если пользователь есть — используется его id для связки постов.
6. Это гарантирует, что фронт сразу покажет данные на карте и в дашборде.

## 23. Поля и типы данных (Postgres)
1. `users.id` — SERIAL PRIMARY KEY.
2. `users.name` — VARCHAR(120) NOT NULL.
3. `users.email` — VARCHAR(160) UNIQUE NOT NULL.
4. `users.password_hash` — TEXT NOT NULL.
5. `users.created_at` — TIMESTAMPTZ DEFAULT NOW().
6. `posts.id` — SERIAL PRIMARY KEY.
7. `posts.user_id` — INTEGER REFERENCES users(id) ON DELETE CASCADE.
8. `posts.title` — VARCHAR(180) NOT NULL.
9. `posts.body` — TEXT.
10. `posts.rating` — INTEGER CHECK (1–5).
11. `posts.price` — NUMERIC(12,2).
12. `posts.city` — VARCHAR(120).
13. `posts.latitude` — DECIMAL(9,6).
14. `posts.longitude` — DECIMAL(9,6).
15. `posts.created_at` — TIMESTAMPTZ DEFAULT NOW().

## 24. Логика фильтров и сортировки (GET /api/posts)
1. Поиск (`search`) идет по LOWER(title) и LOWER(body) через LIKE.
2. `minRating` сравнивается по `>=`.
3. `city` сравнивается по LOWER(city) = LOWER(query).
4. `sort=price` — ORDER BY price DESC NULLS LAST.
5. Любое другое `sort` — ORDER BY created_at DESC.
6. Комбинации фильтров объединяются через AND.

## 25. Авторизация и хранение токена
1. Токен создается в `createToken()` (auth.js), секрет `config.jwtSecret`.
2. Срок жизни — 7 дней.
3. На фронте сохраняется в `localStorage` (`token` и `user`).
4. При загрузке страницы `initAuthState()` читает токен и подставляет имя.
5. При запросах `createPost` токен добавляется в заголовок Authorization.
6. При ошибке 401 стоит залогиниться заново.

## 26. Поток создания карточки на фронте
1. Пользователь логинится → токен сохранен.
2. Заполняет форму: title, body, rating, price, city, lat/long (необязательно).
3. Нажимает «Создать» → `createPost()` шлет POST `/api/posts` с токеном.
4. Сервер сохраняет запись, возвращает созданный пост.
5. Фронт добавляет запись в `posts.unshift`, вызывает `applyFilters()`.
6. Слайдер, таблица, график, карта обновляются сразу.

## 27. Поток получения геолокации
1. Пользователь нажимает «Определить меня».
2. Браузер спрашивает разрешение на геолокацию.
3. При успехе: координаты кэшируются, карта центрируется, ставится круглый маркер.
4. Пользователь может нажать «Подставить мою геолокацию» — координаты копируются в форму.
5. После создания поста с этими координатами на карте появится маркер.

## 28. Как обновить внешний вид или тему
1. Основные цвета заданы в CSS-переменных `:root`.
2. Шрифты подключены через Google Fonts (Space Grotesk, Playfair Display).
3. Сетки: CSS Grid/Flex, mobile-first media queries.
4. Чтобы сменить тему, поменяйте переменные в начале `styles.css`.

## 29. Как добавить новое поле в пост
1. БД: ALTER TABLE posts ADD COLUMN new_field ...;
2. Бэкенд: добавить поле в INSERT/UPDATE/SELECT (routes/posts.js).
3. Фронт: добавить в форму, отрисовку карточек/таблицы, фильтры (если нужно).
4. Обновить сиды (init.js) и документацию.

## 30. Мини-FAQ
1. **В: Не работает карта.**  
   О: Проверьте наличие координат у постов или доступ к интернету для тайлов OSM.
2. **В: При создании поста 401.**  
   О: Нет токена или он истек — залогиньтесь.
3. **В: Пароль хранится в БД в открытом виде?**  
   О: Нет, хранится `password_hash` (bcrypt).
4. **В: Можно ли подключить другой фронт?**  
   О: Да, используйте API /api/* с любой SPA/приложения.
5. **В: Как сменить порт API?**  
   О: Поменять `PORT` в .env или compose.
6. **В: Нужен ли SSL?**  
   О: В продакшене — да, включите HTTPS на уровне прокси и при необходимости `DB_SSL=true`.

## 31. Чек-лист перед защитой
1. Запущен docker-compose, оба контейнера в состоянии healthy.
2. Открыт `http://localhost:3000`, лента/карта/график видны.
3. Демо-вход работает (`demo@elitetime.ru / demo1234`).
4. Создание карточки работает, маркер появляется.
5. Обновление/удаление своей карточки работает, чужие — защищены.
6. README и docs актуальны.
7. `.env` настроен (или переменные в compose), `JWT_SECRET` не дефолтный для проды.

## 32. Полезные команды
1. `docker-compose up --build` — поднять всё.
2. `docker-compose down` — остановить.
3. `psql -h localhost -p 55432 -U elitetime -d elitetime` — зайти в БД.
4. `npm run dev` (в backend/) — запустить Express с nodemon локально.
5. `curl http://localhost:3000/api/health` — проверить БД/сервер.

## 33. Структура ответов API (примеры)
1. Успешный логин:
   ```json
   { "token": "<jwt>", "user": { "id": 1, "name": "Demo", "email": "demo@elitetime.ru" } }
   ```
2. Список постов (фрагмент):
   ```json
   [
     {
       "id": 1,
       "title": "Rolex Submariner — топовая сталь",
       "body": "Отличное состояние...",
       "rating": 5,
       "price": 1200000,
       "city": "Москва",
       "latitude": 55.7558,
       "longitude": 37.6173,
       "created_at": "...",
       "author": "Demo Manager"
     }
   ]
   ```
3. Ошибка авторизации:
   ```json
   { "message": "Требуется авторизация" }
   ```
4. Ошибка валидации (пример):
   ```json
   { "message": "Введите заголовок" }
   ```

## 34. Расширяемость и интеграции
1. Можно подключить внешние карты (Yandex/Google) — заменив Leaflet и источники тайлов.
2. Можно добавить загрузку изображений — хранить ссылки в posts, добавить upload-сервис.
3. Можно вынести фронт в отдельный SPA (React/Vue) — оставить API как есть.
4. Можно добавить роли (admin) — расширить таблицу users и проверки в миддлваре.
5. Можно добавить пагинацию — изменить SELECT + limit/offset, добавить query параметр page.

## 35. Что произойдет при старте backend
1. Читает env (dotenv).
2. Настраивает cors, morgan, json body parser.
3. Подключает маршруты `/api`, `/api/posts`.
4. Отдает статику из FRONTEND_DIR.
5. Для не-API путей — отдает `index.html` (SPA-like fallback).
6. Запускает миграции и сиды.
7. Слушает порт `config.port`.

## 36. Где меняются пути к фронту и БД
1. FRONTEND_DIR — в `.env` или `backend/src/config.js` (по умолчанию `frontend/`).
2. DATABASE_URL — в `.env` или переменных контейнера (в compose указан `postgres://elitetime:elitetime@db:5432/elitetime`).
3. PORT — аналогично.

## 37. Почему используется JWT
1. Легко проверять на сервере без хранения сессий.
2. Можно отдавать фронту и хранить в localStorage.
3. Подходит для SPA/статического фронта.
4. Легко проверять авторство (id в payload).

## 38. Почему Postgres
1. SQL, транзакции, индексы, внешние ключи — проще поддерживать связи users↔posts.
2. Удобно деплоить через официальный образ.
3. Для MVP — достаточно, но можно переключить на любой совместимый сервер (меняя DATABASE_URL).

## 39. Мини-словарь
1. JWT — JSON Web Token, подпись сервера, хранит id/email/name.
2. CRUD — Create, Read, Update, Delete.
3. CORS — Cross-Origin Resource Sharing, позволяет фронту обращаться к API.
4. Seed — предзаполнение БД демо-данными.
5. Healthcheck — быстрый запрос для проверки состояния сервиса.

## 40. Финальный краткий сценарий для проверки экзаменатором
1. `docker-compose up --build`
2. Открыть `http://localhost:3000`
3. Войти демо-аккаунтом
4. Создать пост с координатами
5. Увидеть пост в слайдере, таблице, графике, на карте
6. Обновить/удалить пост — убедиться в проверке авторства
7. Проверить `/api/health` и `/api/profile`
